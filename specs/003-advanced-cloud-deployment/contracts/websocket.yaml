# WebSocket Message Schemas

**Feature**: Advanced Cloud Deployment with Enhanced Task Management
**Date**: 2026-02-10
**Version**: 1.0

## Overview

This document defines the WebSocket message schemas for real-time synchronization between clients and the server. WebSocket connections enable instant updates across all user devices without polling.

## Connection

### Endpoint
```
ws://localhost:8000/ws
wss://todo-app.local/ws  (production)
```

### Authentication

Clients must authenticate using JWT token:

```javascript
const socket = io('ws://localhost:8000', {
  auth: {
    token: 'jwt-token-here'
  }
});
```

### Connection Flow

```
Client                          Server
  |                               |
  |--- Connect with JWT token --->|
  |                               |
  |<--- Connection accepted ------|
  |<--- Join user room ----------|
  |                               |
  |<--- Initial state sync ------|
  |                               |
  |<--- Real-time updates --------|
```

## Message Types

### 1. Client → Server Messages

#### 1.1 Subscribe to Updates

**Purpose**: Subscribe to real-time updates for user's tasks.

**Message**:
```json
{
  "type": "subscribe",
  "data": {
    "user_id": "user-uuid",
    "filters": {
      "status": "incomplete",
      "priority": "high"
    }
  }
}
```

**Response**:
```json
{
  "type": "subscribed",
  "data": {
    "user_id": "user-uuid",
    "room": "user_user-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

#### 1.2 Unsubscribe

**Purpose**: Unsubscribe from updates (before disconnect).

**Message**:
```json
{
  "type": "unsubscribe",
  "data": {
    "user_id": "user-uuid"
  }
}
```

**Response**:
```json
{
  "type": "unsubscribed",
  "data": {
    "user_id": "user-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

#### 1.3 Ping

**Purpose**: Keep connection alive, check latency.

**Message**:
```json
{
  "type": "ping",
  "data": {
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Response**:
```json
{
  "type": "pong",
  "data": {
    "timestamp": "2026-02-10T14:30:00Z",
    "server_timestamp": "2026-02-10T14:30:00.123Z"
  }
}
```

---

### 2. Server → Client Messages

#### 2.1 Task Created

**Purpose**: Notify client that a new task was created.

**Message**:
```json
{
  "type": "task.created",
  "data": {
    "task": {
      "id": 123,
      "title": "New Task",
      "description": "Task description",
      "status": "incomplete",
      "priority": "medium",
      "due_date": "2026-02-15T10:00:00Z",
      "tags": ["work"],
      "created_at": "2026-02-10T14:30:00Z",
      "updated_at": "2026-02-10T14:30:00Z",
      "version": 1
    },
    "source_session": "session-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Add task to local state, update UI.

#### 2.2 Task Updated

**Purpose**: Notify client that a task was updated.

**Message**:
```json
{
  "type": "task.updated",
  "data": {
    "task_id": 123,
    "changes": {
      "title": "Updated Title",
      "priority": "high",
      "version": 2
    },
    "full_task": {
      /* Complete task object (optional) */
    },
    "source_session": "session-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**:
- If `source_session` matches current session, ignore (echo prevention)
- Otherwise, merge changes into local state, update UI

#### 2.3 Task Completed

**Purpose**: Notify client that a task was marked complete.

**Message**:
```json
{
  "type": "task.completed",
  "data": {
    "task_id": 123,
    "completed_at": "2026-02-10T14:30:00Z",
    "version": 2,
    "source_session": "session-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Update task status to complete, move to completed list.

#### 2.4 Task Deleted

**Purpose**: Notify client that a task was deleted.

**Message**:
```json
{
  "type": "task.deleted",
  "data": {
    "task_id": 123,
    "source_session": "session-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Remove task from local state, update UI.

#### 2.5 Tag Added

**Purpose**: Notify client that a tag was added to a task.

**Message**:
```json
{
  "type": "task.tag_added",
  "data": {
    "task_id": 123,
    "tag": {
      "id": 456,
      "name": "urgent",
      "color": "#FF0000"
    },
    "source_session": "session-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Add tag to task's tag list, update UI.

#### 2.6 Tag Removed

**Purpose**: Notify client that a tag was removed from a task.

**Message**:
```json
{
  "type": "task.tag_removed",
  "data": {
    "task_id": 123,
    "tag_id": 456,
    "source_session": "session-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Remove tag from task's tag list, update UI.

#### 2.7 Reminder Scheduled

**Purpose**: Notify client that a reminder was scheduled.

**Message**:
```json
{
  "type": "reminder.scheduled",
  "data": {
    "reminder": {
      "id": 789,
      "task_id": 123,
      "remind_at": "2026-02-15T09:00:00Z",
      "status": "pending"
    },
    "source_session": "session-uuid",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Update task with reminder info, show reminder indicator.

#### 2.8 Reminder Fired

**Purpose**: Notify client that a reminder is due (in-app notification).

**Message**:
```json
{
  "type": "reminder.fired",
  "data": {
    "reminder_id": 789,
    "task": {
      "id": 123,
      "title": "Task Title",
      "due_date": "2026-02-15T10:00:00Z",
      "priority": "high"
    },
    "message": "Task 'Task Title' is due in 1 hour",
    "timestamp": "2026-02-15T09:00:00Z"
  }
}
```

**Client Action**: Show in-app notification, play sound (if enabled).

#### 2.9 Connection Status

**Purpose**: Inform client about connection state changes.

**Message**:
```json
{
  "type": "connection.status",
  "data": {
    "status": "connected | disconnected | reconnecting",
    "message": "Connection established",
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Update connection indicator in UI.

#### 2.10 Error

**Purpose**: Notify client about errors.

**Message**:
```json
{
  "type": "error",
  "data": {
    "code": "UNAUTHORIZED | INVALID_MESSAGE | INTERNAL_ERROR",
    "message": "Error description",
    "details": {
      /* Additional error context */
    },
    "timestamp": "2026-02-10T14:30:00Z"
  }
}
```

**Client Action**: Log error, show user-friendly message if needed.

---

## Client Implementation

### JavaScript/TypeScript Example

```typescript
import { io, Socket } from 'socket.io-client';

class TaskWebSocketClient {
  private socket: Socket;
  private sessionId: string;

  constructor(token: string) {
    this.sessionId = crypto.randomUUID();

    this.socket = io('ws://localhost:8000', {
      auth: { token },
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: 5
    });

    this.setupListeners();
  }

  private setupListeners() {
    // Connection events
    this.socket.on('connect', () => {
      console.log('Connected to WebSocket server');
      this.subscribe();
    });

    this.socket.on('disconnect', () => {
      console.log('Disconnected from WebSocket server');
    });

    // Task events
    this.socket.on('task.created', (data) => {
      if (data.source_session !== this.sessionId) {
        this.handleTaskCreated(data.task);
      }
    });

    this.socket.on('task.updated', (data) => {
      if (data.source_session !== this.sessionId) {
        this.handleTaskUpdated(data.task_id, data.changes);
      }
    });

    this.socket.on('task.completed', (data) => {
      if (data.source_session !== this.sessionId) {
        this.handleTaskCompleted(data.task_id);
      }
    });

    this.socket.on('task.deleted', (data) => {
      if (data.source_session !== this.sessionId) {
        this.handleTaskDeleted(data.task_id);
      }
    });

    // Reminder events
    this.socket.on('reminder.fired', (data) => {
      this.showNotification(data.message, data.task);
    });

    // Error handling
    this.socket.on('error', (data) => {
      console.error('WebSocket error:', data);
    });
  }

  private subscribe() {
    this.socket.emit('subscribe', {
      user_id: this.getUserId(),
      filters: {}
    });
  }

  private handleTaskCreated(task: Task) {
    // Update local state
    store.dispatch(addTask(task));
  }

  private handleTaskUpdated(taskId: number, changes: any) {
    // Merge changes into local state
    store.dispatch(updateTask(taskId, changes));
  }

  private handleTaskCompleted(taskId: number) {
    // Mark task as complete
    store.dispatch(completeTask(taskId));
  }

  private handleTaskDeleted(taskId: number) {
    // Remove task from local state
    store.dispatch(deleteTask(taskId));
  }

  private showNotification(message: string, task: Task) {
    // Show in-app notification
    if (Notification.permission === 'granted') {
      new Notification('Task Reminder', {
        body: message,
        icon: '/icon.png',
        tag: `task-${task.id}`
      });
    }
  }

  disconnect() {
    this.socket.disconnect();
  }
}
```

---

## Server Implementation

### Python Example (FastAPI + Socket.io)

```python
from socketio import AsyncServer, AsyncRedisManager
from fastapi import FastAPI
import json

# Redis manager for multi-instance broadcasting
redis_manager = AsyncRedisManager('redis://redis:6379')
sio = AsyncServer(
    async_mode='asgi',
    client_manager=redis_manager,
    cors_allowed_origins='*'
)

app = FastAPI()
app.mount('/ws', socketio.ASGIApp(sio))

@sio.event
async def connect(sid, environ, auth):
    """Handle client connection."""
    token = auth.get('token')

    # Verify JWT token
    user_id = await verify_token(token)
    if not user_id:
        raise ConnectionRefusedError('Invalid token')

    # Store user_id in session
    await sio.save_session(sid, {'user_id': user_id})

    # Join user's room
    await sio.enter_room(sid, f"user_{user_id}")

    print(f"Client {sid} connected (user: {user_id})")

@sio.event
async def disconnect(sid):
    """Handle client disconnection."""
    session = await sio.get_session(sid)
    user_id = session.get('user_id')
    print(f"Client {sid} disconnected (user: {user_id})")

@sio.event
async def subscribe(sid, data):
    """Handle subscription request."""
    session = await sio.get_session(sid)
    user_id = session.get('user_id')

    await sio.emit('subscribed', {
        'user_id': user_id,
        'room': f"user_{user_id}",
        'timestamp': datetime.utcnow().isoformat() + 'Z'
    }, room=sid)

@sio.event
async def ping(sid, data):
    """Handle ping request."""
    await sio.emit('pong', {
        'timestamp': data.get('timestamp'),
        'server_timestamp': datetime.utcnow().isoformat() + 'Z'
    }, room=sid)

# Broadcast task updates (called from Kafka consumer)
async def broadcast_task_update(user_id: str, event_type: str, data: dict):
    """Broadcast task update to all user's connected clients."""
    await sio.emit(
        event_type,
        data,
        room=f"user_{user_id}"
    )
```

---

## Connection Management

### Reconnection Strategy

**Client-side**:
- Automatic reconnection with exponential backoff
- Max 5 reconnection attempts
- Delay: 1s, 2s, 4s, 8s, 16s

**Server-side**:
- Maintain connection state in Redis
- Clean up stale connections after 5 minutes

### Heartbeat

- Client sends `ping` every 30 seconds
- Server responds with `pong`
- If no `pong` received within 10 seconds, reconnect

---

## Scaling Considerations

### Multi-Instance Deployment

**Challenge**: WebSocket connections are stateful, clients connect to specific server instances.

**Solution**: Redis Pub/Sub for broadcasting across instances.

```
Client A → Instance 1 → Redis Pub/Sub → Instance 2 → Client B
```

**Implementation**:
- Use Socket.io Redis adapter
- All instances subscribe to Redis channels
- Broadcasts go through Redis to reach all instances

### Load Balancing

**Strategy**: Sticky sessions (session affinity)

**Configuration** (Nginx):
```nginx
upstream websocket_backend {
    ip_hash;  # Sticky sessions
    server instance1:8000;
    server instance2:8000;
    server instance3:8000;
}

server {
    location /ws {
        proxy_pass http://websocket_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

---

## Security

### Authentication

- JWT token required for connection
- Token verified on connect
- Invalid token → connection refused

### Authorization

- Clients only receive updates for their own tasks
- Room-based isolation (user_user-uuid)
- No cross-user data leakage

### Rate Limiting

- Max 100 messages per minute per client
- Exceeded → temporary disconnect

---

## Monitoring

### Metrics to Track

- **Active Connections**: Number of connected clients
- **Connection Duration**: How long clients stay connected
- **Message Rate**: Messages/second per client
- **Broadcast Latency**: Time from event to client delivery
- **Reconnection Rate**: How often clients reconnect

### Logging

```python
logger.info(
    "WebSocket message",
    extra={
        "event_type": "task.updated",
        "user_id": user_id,
        "client_id": sid,
        "latency_ms": latency
    }
)
```

---

## Summary

This WebSocket schema provides:
- Real-time task synchronization across devices
- Echo prevention via source_session tracking
- Automatic reconnection with exponential backoff
- Multi-instance support via Redis Pub/Sub
- Secure authentication and authorization
- Comprehensive error handling

Clients receive instant updates without polling, enabling seamless multi-device experiences.
